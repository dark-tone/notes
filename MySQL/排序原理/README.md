# 排序原理
在MySQL中的ORDER BY有两种排序实现方式：
1. 利用有序索引获取有序数据；
2. 文件排序。

在使用explain分析查询的时候，利用有序索引获取有序数据显示Using index。如果MySQL在排序的时候没有使用到索引那么就会输出using filesort，即使用文件排序。这里主要总结文件排序的原理。

## 相关参数
### sort_buffer_size:
MySQL会给每个线程分配一块内存区域用于排序，这块区域叫sort_buffer。如果待排序的数据足够存放在sort_buffer中，那么就会直接用这块区域进行排序，算法为快速排序；如果待排序的数据超过了sort_buffer大小，会使用磁盘临时文件来辅助排序，算法为归并排序。

### max_length_for_sort_data：
如果排序返回行的字段长度综合大约这个值，使用二次排序（双路排序）而不是一次排序（单路排序）。
>**为什么？**<br>
>如果单行数据量太大，内存中能存储下的行数就会变少，就需要使用更多的磁盘临时文件来存储，排序的性能会比较差。

### read_rnd_buffer_size：
回表排序需要两次IO，一次是捞(id,col2),第二次是捞(col1,col2,col3)，由于返回的结果集是按col2排序，因此id是乱序的，通过乱序的id去捞(col1,col2,col3)时会产生大量的随机IO。对于第二次MySQL本身一个优化，即在捞之前首先将id排序，并放入缓冲区，这个缓存区大小由参数read_rnd_buffer_size控制，然后有序去捞记录，将随机IO转为顺序IO。
    
### max_sort_length：
max_sort_length是键值对的大小无法确定时（比如用户要查询的数据包含了 SUBSTRING_INDEX(col1, ‘.’,2)）MySQL会对每个键值对分配max_sort_length个字节的内存。

## 双路排序（回表排序、RowId排序）
### 原理
第一遍扫描出需要排序的字段，然后进行排序后，根据排序结果，第二遍再扫描一下需要select的列数据。这样会引起大量的随机IO，效率不高，但是节约内存。排序使用quick sort，但是如果内存不够则会按照block进行排序，将排序结果写入磁盘文件，然后再将结果合并。

### 具体过程：

1、读取所有满足条件的记录。

2、对于每一行，存储一对值到缓冲区（排序列，行记录指针），一个是排序的索引列的值，即order by用到的列值，和指向该行数据的行指针（缓冲区的大小为sort_buffer_size大小）。

3、当缓冲区满后，运行一个快速排序（qsort）来将缓冲区中数据排序，并将排序完的数据存储到一个临时文件，并保存一个存储块的指针，当然如果缓冲区不满，则不会重建临时文件了。

4、重复以上步骤，直到将所有行读完，并建立相应的有序的临时文件。

5、对块级进行排序，这个类似于归并排序算法，只通过两个临时文件的指针来不断交换数据，最终达到两个文件，都是有序的。

6、重复5直到所有的数据都排序完毕。

7、采取顺序读的方式，将每行数据读入内存，并取出数据传到客户端，这里读取数据时并不是一行一行读，读取缓存大小由read_rnd_buffer_size来指定。

### 特点

采取的方法为：快速排序 + 归并排序。

但有一个问题，就是，一行数据会被读两次，第一次是where条件过滤时，第二个是排完序后还得用行指针去读一次，一个优化的方法是，直接读入数据，排序的时候也根据这个排序，排序完成后，就直接发送到客户端了。


## 单路排序（不回表排序、全字段排序）
在MySQL4.1版本之前只有第一种排序算法双路排序，第二种算法是从MySQL4.1开始的改进算法，主要目的是为了减少第一次算法中需要两次访问表数据的IO操作，将两次变成了一次，但相应也会耗用更多的sortbuffer空间。当然，MySQL4.1开始的以后所有版本同时也支持第一种算法。

### 原理

即一遍扫描数据后将select需要的列数据以及排序的列数据都取出来，然后在sort buffer中排序，这样就不需要进行第二遍扫描了，当然内存不足时还是会使用磁盘临时文件进行外排。

### 具体过程：

1、读取满足条件的记录

2、对于每一行，记录排序的key和数据行指针，并且把要查询的列也读出来

3、根据索引key排序

4、读取排序完成的文件，并直接根据数据位置读取数据返回客户端，而不是去访问表

### 特点

单路排序一次性将结果读取出来，然后在sort buffer中排序，避免了双路排序的两次读的随机IO。

这也有一个问题：当获取的列很多的时候，排序起来就很占空间，因此，max_length_for_sort_data变量就决定了是否能使用这个排序算法。

MySQL根据sort_buffer_size来判断是否使用磁盘临时文件，如果需要排序的数据能放入sort_buffer_size则无需使用磁盘临时文件，此时explain只会输出using filesort否则需要使用磁盘临时文件explain会输出using temporary;using filesort。

### pack优化
以前，存储了“yes”3个字符的定义为VARCHAR(255)的列会在内存中申请255个字符内存空间，但是5.7.3改进后，只需要存储2个字节的字段长度和3个字符内存空间（用于保存”yes”这三个字符）就够了，内存空间整整压缩了50多倍,可以让更多的键值对保存在sort buffer中。


## 优先队列排序
当存在limit字句时，并且limit需要的维护的最大堆的大小小于sort_buffer，就会使用这个算法。也可以认为是上述两种排序方式的limit使用方式。

5.6版本针对Order by limit M，N语句，在空间层面做了优化，加入了一种新的排序方式--优先队列，这种方式采用堆排序实现。堆排序算法特征正好可以解limit M，N 这类排序的问题，虽然仍然需要所有元素参与排序，但是只需要M+N个元组的sort buffer空间即可，对于M，N很小的场景，基本不会因为sort buffer不够而导致需要临时文件进行归并排序的问题。对于升序，采用大顶堆，最终堆中的元素组成了最小的N个元素，对于降序，采用小顶堆，最终堆中的元素组成了最大的N的元素。

## 优化总结
- 尽量不适用select *，只获取需要的field，有数量关系时使用limit关键字;
- 使用索引来优化或者避免排序;
- 增加sort_buffer_size大小，避免磁盘排序;
- 不得不使用回表排序算法时，增加read_rnd_buffer_size;
- mpdir建议独立存放，放在高速存储设备上。

# 参考文章
[MySQL排序原理](https://blog.csdn.net/eagle89/article/details/81315981)

[从排序原理到MYSQL中的排序方式](http://blog.itpub.net/7728585/viewspace-2130743/)

[数据库优化<六>SQL优化之SELECT优化 ——filesort](https://blog.csdn.net/xiaobing_blog/article/details/17152777)

[MySQL filesort原理及优化](https://zhuanlan.zhihu.com/p/311933050)
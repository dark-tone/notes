# TCP三次握手四次挥手

## TCP报文首部格式
<img src="https://raw.githubusercontent.com/dark-tone/notes/main/%E7%BD%91%E7%BB%9C%E7%9B%B8%E5%85%B3/imgs/1.jpg" weight="571" height="379">

1. 源端口和目的端口（Source Port和Destination Port）：分别占用2个字节，用于区别主机中的不同进程，而IP地址是用来区分不同的主机的，源端口号和目的端口号配合上IP首部中的源IP地址和目的IP地址就能唯一的确定一个TCP连接。
2. 序号seq（Sequence Number）：占4个字节，用来标识从TCP发端向TCP收端发送的数据字节流（tcp传输的每一个字节都按顺序编号），它表示在这个报文段中的第一个数据字节在数据流中的序号。主要用来解决网络报乱序的问题。
3. 确认号ack（Acknowledgment Number）：占4个字节，确认序列号包含发送确认的一端所期望收到的下一个序号，因此，确认序号应当是上次已成功收到数据字节序号加1。不过，只有当标志位中的ACK标志为1时该确认序列号的字段才有效。主要用来解决不丢包的问题（确认序号减去上次收到的序号等于本段收到的报文的长度）。
4. 数据偏移（Offset）：占4个bit，指出tcp报文段的数据起始处距离tcp报文段的起始有多远，这个字段实际指出Ttcp报文段的首部长度。需要这个值是因为任选字段的长度是可变的，它用来表示首部中32bit（4字节）字的数目，因此最多能表示15个32bit的的字，即4*15=60个字节的首部长度），因此TCP最多有60字节的首部。然而，没有任选字段，正常的长度是20字节。
5. 保留：占6bit。
6. TCP Flags：TCP首部中有6个标志比特，它们中的多个可同时被设置为1，主要是用于操控TCP的状态机的，依次为URG，ACK，PSH，RST，SYN，FIN。每个标志位的意思如下：
    - 紧急URG：当URG = 1时，表示TCP包的紧急指针域有效，告诉系统这个报文段中有紧急数据，应当尽快传输。
    - 确认ACK：TCP应答号将会包含在TCP数据包中，有两个取值：0和1，为1的时候表示应答域有效，反之为0。
    - 推送PSH：这个标志位表示Push操作，接收方tcp收到PSH = 1的报文段，就尽快交付给接收接收应用进程而不是再等到这个缓冲区都填满之后再向上交付。
    - 复位RST：表示连接复位请求，当RST = 1，标明tcp有严重的错误，必须释放连接，重新建立运输连接。RST = 1还可以用来拒绝一个非法的报文段或者拒绝打开一个连接。
    - 同步SYN：表示同步序号，用来建立连接，SYN标志位和ACK标志位搭配使用，当连接请求的时候，SYN=1，ACK=0；连接被响应的时候，SYN=1，ACK=1；这个标志的数据包经常被用来进行端口扫描。扫描者发送一个只有SYN的数据包，如果对方主机响应了一个数据包回来 ，就表明这台主机存在这个端口；但是由于这种扫描方式只是进行TCP三次握手的第一次握手，因此这种扫描的成功表示被扫描的机器不很安全，一台安全的主机将会强制要求一个连接严格的进行TCP的三次握手。
    - 终止FIN： 表示发送端已经达到数据末尾，将释放一个连接，FIN = 1， 表示报文段的发送方的数据已经发送完成，请求释放连接。
7. 窗口：占2个字节，存放的是数据是字节为单位的窗口值告诉对方，本报文段首部中的确认号算起，接收方目前允许对方发送的数据量。这是让发送方设置发送窗口的依据。
8. 检验和，占2个字节。

要理解三次握手，四次挥手，同步SYN、确认ACK、序号seq、确认号ack、终止FIN5个概念比较重要，下面再次加深这5个概念的理解：
- 同步SYN：在连接建立时用来同步序号，当SYN=1而ACK=0时，表明这是一个连接请求报文，对方若同意建立连接，则应在响应报文中使SYN=1和ACK=1，SYN置1就表示这是一个连接请求或连接接受报文。
- 确认ACK：TCP协议规定，只有ACK=1时有效，也规定连接建立后所有发送的报文的ACK必须为1。
- 序号seq：标识从TCP发端向TCP收端发送的数据字节流（tcp传输的每一个字节都按顺序编号），它表示在这个报文段中的的第一个数据字节在数据流中的序号。
- 确认号ack：确认序列号包含发送确认的一端所期望收到的下一个序号，因此，确认序号应当是上次已成功收到数据字节序号加1。不过，只有当标志位中的ACK标志为1时该确认序列号的字段才有效。
- 终止FIN：表示发送端已经达到数据末尾，也就是说双方的数据传送完成，没有数据可以传送了，发送FIN标志位的TCP数据包后，连接将被断开。

## 三次握手
### 示意图
<img src="https://raw.githubusercontent.com/dark-tone/notes/main/%E7%BD%91%E7%BB%9C%E7%9B%B8%E5%85%B3/imgs/2.jpg" weight="492" height="303">

### 为什么是三次握手
1. 原理：确认双方都可以收到并同意对方的请求，刚好是三次来回。
    >A--请求-->B<br>
A<--确认--B<br>
A<--请求--B<br>
A--确认-->B<br>
中间两次可以一起返回，所以是三次
2. 防止失效的连接请求报文段被服务端接收，从而产生错误。

## 四次挥手
### 示意图
<img src="https://raw.githubusercontent.com/dark-tone/notes/main/%E7%BD%91%E7%BB%9C%E7%9B%B8%E5%85%B3/imgs/3.jpg" weight="676" height="416">

### 具体过程
#### 第一次挥手
若A认为数据发送完成，则它需要向B发送连接释放请求。该请求只有报文头，头中携带的主要参数为： FIN=1，seq=u。此时，A将进入FIN-WAIT-1状态。PS1：FIN=1表示该报文段是一个连接释放请求。PS2：seq=u，u-1是A向B发送的最后一个字节的序号。

#### 第二次挥手
B收到连接释放请求后，会通知相应的应用程序，告诉它A向B这个方向的连接已经释放。此时B进入CLOSE-WAIT状态，并向A发送连接释放的应答，其报文头包含： ACK=1，seq=v，ack=u+1。PS1：ACK=1：除TCP连接请求报文段以外，TCP通信过程中所有数据报的ACK都为1，表示应答。PS2：seq=v，v-1是B向A发送的最后一个字节的序号。PS3：ack=u+1表示希望收到从第u+1个字节开始的报文段，并且已经成功接收了前u个字节。A收到该应答，进入FIN-WAIT-2状态，等待B发送连接释放请求。**第二次挥手完成后，A到B方向的连接已经释放，B不会再接收数据，A也不会再发送数据**。但B到A方向的连接仍然存在，B可以继续向A发送数据。

#### 第三次挥手
当B向A发完所有数据后，向A发送连接释放请求，请求头：FIN=1，ACK=1，seq=w，ack=u+1。B便进入LAST-ACK状态。

#### 第四次挥手
A收到释放请求后，向B发送确认应答，此时A进入TIME-WAIT状态。该状态会持续2MSL时间，若该时间段内没有B的重发请求的话，就进入CLOSED状态，撤销TCB。当B收到确认应答后，也便进入CLOSED状态，撤销TCB。

### 为什么A要先进入TIME-WAIT状态，等待2MSL时间后才进入CLOSED状态？
为了保证B能收到A的确认应答。 若A发完确认应答后直接进入CLOSED状态，那么如果该应答丢失，B等待超时后就会重新发送连接释放请求，但此时A已经关闭了，不会作出任何响应，因此B永远无法正常关闭。


# 参考文章
[TCP/IP--理解TCP三次握手和四次挥手](https://www.jianshu.com/p/4084a9397138)

[TCP 为什么是三次握手，而不是两次或四次？ - 大闲人柴毛毛的回答 - 知乎](https://www.zhihu.com/question/24853633/answer/254224088)
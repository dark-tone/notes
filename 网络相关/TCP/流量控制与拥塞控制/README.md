# 流量控制
所谓流量控制就是让发送方的发送速率不要太快，要让接收方来得及接收。

## 滑动窗口（rwnd）
TCP每发送一个数据，都需要进行一次应答。当收到了上一个应答，在发下一个数据，但这种方式效率比较低。数据包往返时间越长，通信的效率就越低。
  为了解决这个问题，TCP引入了窗口概念。即在接收窗口范围内的数据，无需等待确认，可以继续发送窗口内数据，直到把发送窗口数据传输完毕。
  窗口的实现实际上是在操作系统开辟一个缓存空间（空间和序号都是有限的，并且要循环使用，一般为环形队列），发送主机在等到确认应答返回之前，必须在缓冲区保留已发送窗口的数据（超时重传）。收到应答后，将此数据清除。

<img src="https://raw.githubusercontent.com/dark-tone/notes/main/网络相关/TCP/imgs/1.jpg" weight="562">

# 拥塞控制
所谓拥塞控制就是防止过多的数据注入到网络中，这样可以使网络中的路由器或链路不致过载。

只要发送方没有在规定时间内接收到 ACK 应答报⽂，也就是发⽣了超时重传，就会认为⽹络出现了拥塞。

<img src="https://raw.githubusercontent.com/dark-tone/notes/main/网络相关/TCP/imgs/2.webp">

## 慢开始和拥塞避免
**拥塞窗口**：发送方维持一个叫拥塞窗口 cwnd的状态变量。大小取决于网络的拥塞程度并动态变化，发送方的发送窗口等于拥塞窗口（不考虑接收方窗口的情况下，实际是两者取min）。

**慢开始算法**：当发送⽅每收到⼀个 ACK，拥塞窗⼝ cwnd 的⼤⼩就会加 1。
> 连接建⽴完成后，⼀开始初始化 cwnd = 1 ，表示可以传⼀个 MSS ⼤⼩的数据。
当收到⼀个 ACK 确认应答后，cwnd 增加 1，于是⼀次能够发送 2 个
当收到 2 个的 ACK 确认应答后， cwnd 增加 2，于是就可以⽐之前多发2 个，所以这⼀次能够发送 4 个
当这 4 个的 ACK 确认到来的时候，每个确认 cwnd 增加 1， 4 个确认 cwnd 增加 4，于是就可以⽐之前多发 4
个，所以这⼀次能够发送 8 个。

**慢开始门限**：为了防止拥塞窗口cwnd增长过大引起网络拥塞。
> 当 cwnd < ssthresh 时，使⽤慢开始算法。<br>
当 cwnd >= ssthresh 时，就会使⽤拥塞避免算法。<br>
当 cwnd = ssthresh，既可以使用慢开始算法，也可用拥塞避免算法。

**拥塞避免算法**：与慢开始算法相比，每经过一个往返时间RTT就把发送方的拥塞窗口cwnd加1，而不是加倍。（即线性规律增长）

## 快重传
如下图所示，接收方收到了M1和M2后都分别及时发出了确认。现假定接收方没有收到M3但却收到了M4。本来接收方可以什么都不做。但按照快重传算法，接收方必须立即发送对M2的重复确认，以便让发送方尽早知道接收方没有收到报文段M3。发送方接着发送M5和M6.接收方收到后也仍要再次分别发出对M2的重复确认。

快重传算法规定，发送方只要一连收到3个重复确认，就知道接收方确实没有收到报文段M3，因而应该立即进行重传(即“快重传”)，这样就不会出现超时 (如果没有快重传，只要发生超时就执行门限ssthresh / 2,然后慢开始) ，发送方也不就会误认为出现了网络拥塞。使用快重传可以使整个网络的吞吐量提高约20%。

<img src="https://raw.githubusercontent.com/dark-tone/notes/main/网络相关/TCP/imgs/3.jpg">

## 快恢复
快恢复一般与快重传配合使用，其过程有以下两个要点：

（1）当发送方连续收到三个重复确认时，把慢开始门限ssthresh减半。

（2）ssthresh减半后不执行慢开始算法，而是把cwnd值设置为慢开始门限减半后的数值，然后开始拥塞避免算法。

上图的TCP Reno版本使用的就是快恢复算法。

# 参考资料
《计算机网络》

[TCP的流量控制](https://blog.csdn.net/ZBraveHeart/article/details/123820768)

[详解TCP拥塞控制](https://blog.csdn.net/qq_46312987/article/details/124061775)

[TCP滑动窗口](https://blog.csdn.net/ZBraveHeart/article/details/123691305)
## 技巧
#### 从要求的时间/空间复杂度分析
比如要求O(logn)的时间复杂度，则大概率是二分查找相关问题。O(n)则是要求遍历一次获得结果等等


## 快慢指针类型问题
快慢指针主要解决**链表**相关问题。
### 问题1：判断一个链表中是否含有环
#### 思路
同时将fast和slow置为开头节点，一快一慢，如果有环则必相遇。

### 问题2：若一个链表中含有环，找到环开始的位置
#### 思路
设slow走过路程为x，环长为y，则有2x = x + ny，即x = ny，那么fast第二次从头开始则会在环的起点处相遇。

#### 具体实现
1. 初始化：快指针fast指向头结点， 慢指针slow指向头结点
2. 让fast一次走两步， slow一次走一步，第一次相遇在C处，停止
3. 然后让fast指向头结点，slow原地不动，然后fast，slow每次走一步，当再次相遇，就是入口结点。

### 问题3：求有序链表的值域的中位数（需要注意链表的长度的奇偶数问题）
#### 思路
fast每次走两步，slow走一步，则fast到头时slow刚好位于中间。

### 问题4：求链表最后k个节点
#### 思路
fast比slow先走k步，注意边界情况即可。


## 二分法类型问题
### 模板
```
...
// 需要根据实际情况判断边界情况的去留问题
left, right := 0, len(data) - 1
  for left <= right {
    pointer := (left + right) / 2
    // pointer := left + (right - left) / 2
    if data[pointer] > k {
      right = pointer - 1
    } else if data[pointer] < k {
      left = pointer + 1
    } else if data[pointer] == k {
      // do something
    }
  }
```
### 问题1：数字在升序数组中出现的次数

### 问题2：旋转数组的最小数字 
#### 描述
有一个长度为 n 的非降序数组，比如[1,2,3,4,5]，将它进行旋转，即把一个数组最开始的若干个元素搬到数组的末尾，变成一个旋转数组，比如变成了[3,4,5,1,2]，或者[4,5,1,2,3]这样的。请问，给定这样一个旋转数组，求数组中的最小值。

#### 思路
1. 数组可以分为两个有序的子数组。其中，左排序的数组的值大于右排序数组中的值。
2. 声明left,right 分别指向数组的左右两端；
3. mid = (left+right) / 2 为二分的中间位置。
4. mid，left,right分为三种情况：<br>
    a. rotateArray[mid] > rotateArray[right]时， 那么 最小值一定在 [mid+1,right]区间中；<br>
    b. rotateArray[mid] < rotateArray[right]时，那么最小值一定在[left,mid]区间内。（注意这里不能-1）<br>
    c. rotateArray[mid] = rotateArray[right]时，无法判断最小值在哪个区间，所以此时只能缩小right的值。

### 问题3：0～n-1中缺失的数字


## 其他常见算法题
### 二维有序数组查找对应值
#### 描述
在一个二维数组array中（每个一维数组的长度相同），每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。

#### 解法一
根据题目特性：<br>
由于行列递增，可以得出：<br>
1. 在一列中的某个数字，其上的数字都比它小<br>
2. 在一行中的某个数字，其右的数字都比它大<br>
搜索流程：<br>
1. 首先从数组**左下角**搜索.<br>
2. 如果当前数字大于target,那么查找往上移一位,如果当前数字小于target,那么查找往右移一位。
3. 查找到target,返回true; 如果越界，返回false;

#### 解法二
解题思路： 利用数组每行每列都是递增特性。<br>
主要思路： **逐行使用二分搜索**，查找是否含有target<br>


### 合并两个有序的链表
#### 技巧
一般创建单链表，都会设一个虚拟头结点，也叫哨兵，因为这样每一个结点都有一个前驱结点。

#### 具体实现
1. 初始化：定义cur指向新链表的头结点
2. 如果l1指向的结点值小于等于l2指向的结点值，则将l1指向的结点值链接到cur的next指针，然后l1指向下一个结点值
3. 否则，让l2指向下一个结点值
4. 循环步骤2,3，直到l1或者l2为nullptr
5. 将l1或者l2剩下的部分链接到cur的后面

### 两个链表的第一个公共结点
#### 描述
输入两个无环的单向链表，找出它们的第一个公共结点，如果没有公共节点则返回空。

#### 思路
使用两个指针N1,N2，一个从链表1的头节点开始遍历，我们记为N1，一个从链表2的头节点开始遍历，我们记为N2。

让N1和N2一起遍历，当N1先走完链表1的尽头（为null）的时候，则从链表2的头节点继续遍历，同样，如果N2先走完了链表2的尽头，则从链表1的头节点继续遍历，也就是说，N1和N2都会遍历链表1和链表2。

因为两个指针，同样的速度，走完同样长度（链表1+链表2），不管两条链表有无相同节点，都能够到达同时到达终点。

（N1最后肯定能到达链表2的终点，N2肯定能到达链表1的终点）。

所以，如何得到公共节点：
- 有公共节点的时候，N1和N2必会相遇，因为长度一样嘛，速度也一定，必会走到相同的地方的，所以当两者相等的时候，则会第一个公共的节点
- 无公共节点的时候，此时N1和N2则都会走到终点，那么他们此时都是null，所以也算是相等了。

#### 示意图
<img src="https://raw.githubusercontent.com/dark-tone/notes/main/%E7%AE%97%E6%B3%95/imgs/1.gif">
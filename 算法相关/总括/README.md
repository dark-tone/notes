## 技巧
#### 从要求的时间/空间复杂度分析
比如要求O(logn)的时间复杂度，则大概率是二分查找相关问题。O(n)则是要求遍历一次获得结果等等


## 其他常见算法题
### 二维有序数组查找对应值
#### 描述
在一个二维数组array中（每个一维数组的长度相同），每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。

#### 解法一
根据题目特性：<br>
由于行列递增，可以得出：<br>
1. 在一列中的某个数字，其上的数字都比它小<br>
2. 在一行中的某个数字，其右的数字都比它大<br>
搜索流程：<br>
1. 首先从数组**左下角**搜索.<br>
2. 如果当前数字大于target,那么查找往上移一位,如果当前数字小于target,那么查找往右移一位。
3. 查找到target,返回true; 如果越界，返回false;

#### 解法二
解题思路： 利用数组每行每列都是递增特性。<br>
主要思路： **逐行使用二分搜索**，查找是否含有target<br>


### 合并两个有序的链表
#### 技巧
一般创建单链表，都会设一个虚拟头结点，也叫哨兵，因为这样每一个结点都有一个前驱结点。

#### 具体实现
1. 初始化：定义cur指向新链表的头结点
2. 如果l1指向的结点值小于等于l2指向的结点值，则将l1指向的结点值链接到cur的next指针，然后l1指向下一个结点值
3. 否则，让l2指向下一个结点值
4. 循环步骤2,3，直到l1或者l2为nullptr
5. 将l1或者l2剩下的部分链接到cur的后面

### 两个链表的第一个公共结点
#### 描述
输入两个无环的单向链表，找出它们的第一个公共结点，如果没有公共节点则返回空。

#### 思路
使用两个指针N1,N2，一个从链表1的头节点开始遍历，我们记为N1，一个从链表2的头节点开始遍历，我们记为N2。

让N1和N2一起遍历，当N1先走完链表1的尽头（为null）的时候，则从链表2的头节点继续遍历，同样，如果N2先走完了链表2的尽头，则从链表1的头节点继续遍历，也就是说，N1和N2都会遍历链表1和链表2。

因为两个指针，同样的速度，走完同样长度（链表1+链表2），不管两条链表有无相同节点，都能够到达同时到达终点。

（N1最后肯定能到达链表2的终点，N2肯定能到达链表1的终点）。

所以，如何得到公共节点：
- 有公共节点的时候，N1和N2必会相遇，因为长度一样嘛，速度也一定，必会走到相同的地方的，所以当两者相等的时候，则会第一个公共的节点
- 无公共节点的时候，此时N1和N2则都会走到终点，那么他们此时都是null，所以也算是相等了。

#### 示意图
<img src="https://raw.githubusercontent.com/dark-tone/notes/main/%E7%AE%97%E6%B3%95/imgs/1.gif">
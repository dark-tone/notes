# 概念
go的变量要不在栈上要不在堆上，栈上的变量会在函数销毁的时候就释放了，堆上的就要靠gc算法来了，我们一般说从栈逃逸到堆上或者一开始直接就在堆上的变量内存叫做内存逃逸。
> 函数的内部中不对外开放的局部变量，并只作用于当前函数中的变量，它的内存是分配在栈中。执行函数前会执行进栈操作，函数结束后会出栈，同时释放内存。

# 栈
在Go中，栈的内存是由编译器自动进行分配和释放，栈区往往存储着函数参数、局部变量和调用函数帧，它们随着函数的创建而分配，函数的退出而销毁。

一个goroutine对应一个栈，栈是调用栈（call stack）的简称。一个栈通常又包含了许多栈帧（stack frame），它描述的是函数之间的调用关系，每一帧对应一个尚未返回的函数调用，它本身也是以栈形式存放数据。

# 堆
与栈不同的是，应用程序在运行时只会存在一个堆。

我们可以简单理解为：我们在GO开发过程中要考虑的内存管理只是针对堆内存而言的。

程序在运行期间可以主动从堆上申请内存，这些内存通过Go的内存分配器分配，并由垃圾收集器回收。

# 栈和堆的对比
- 栈不需要加锁：栈是每个goroutine独有的，这就意味着栈上的内存操作是不需要加锁的。
- 堆有时需要加锁：堆上的内存，有时需要加锁防止多线程冲突

>**为什么堆上的内存有时需要加锁？而不是一直需要加锁呢？**<br>
因为Go的内存分配策略学习了TCMalloc的线程缓存思想，他为每个处理器P分配了一个mcache，从mcache分配内存也是无锁的

# 性能
- 堆内存管理 性能差：对于程序堆上的内存回收，还需要通过标记清除阶段，例如Go采用的三色标记法。
- 栈内存管理 性能好：栈上的内存，它的分配与释放非常高效的。简单地说，它只需要两个CPU指令：一个是分配入栈，另外一个是栈内释放。只需要借助于栈相关寄存器即可完成。

# 缓存策略
- 栈缓存性能更好
- 堆缓存性能较差

原因是：栈内存能更好地利用CPU的缓存策略，因为栈空间相较于堆来说是更连续的。

# 逃逸分析
Go编译器会尽可能将变量分配到到栈上。

但是，当编译器无法证明函数返回的变量有没有被引用时，那么编译器就必须在堆上分配该变量，以此避免悬挂指针（dangling pointer）的问题。另外，如果局部变量占用内存非常大，也会将其分配在堆上。

编译器通过逃逸分析技术去选择堆或者栈，逃逸分析的基本思想如下：**检查变量的生命周期是否是完全可知的，如果通过检查，则在栈上分配。否则，就是所谓的逃逸，必须在堆上进行分配**。

# 逃逸分析原则
Go语言虽然没有明确说明逃逸分析原则，但是有以下几点准则，是可以参考的。

- 不同于JAVA JVM的运行时逃逸分析，Go的逃逸分析是在编译期完成的：编译期无法确定的参数类型必定放到堆中；
- 如果变量在函数外部存在引用，则必定放在堆中；
- 如果变量占用内存较大时，则优先放到堆中；
- 如果变量在函数外部没有引用，则优先放到栈中；

# 引发内存逃逸的常见情况
- 在方法内把局部变量指针返回，被外部引用，其生命周期大于栈，则溢出。
- 发送指针或带有指针的值到channel，因为编译时候无法知道那个goroutine会在channel接受数据，编译器无法知道什么时候释放。
- 在一个切片上存储指针或带指针的值。比如[]*string，导致切片内容逃逸，其引用值一直在堆上。
- 因为切片的append导致超出容量，切片重新分配地址，切片背后的存储基于运行时的数据进行扩充，就会在堆上分配。
- 在interface类型上调用方法，在Interface调用方法是动态调度的，只有在运行时才知道。

# 逃逸分析举例
## 参数是interface类型
interface{}类型，编译期无法确定其具体的参数类型，所以内存分配到堆中。
## 变量在函数外部有引用
## 变量内存占用较大
## 变量大小不确定时
``` GO
package main

func test() {
l := 1
a := make([]int, l, l)
for i := 0; i < l; i++ {
a[i] = i
}
}

func main() {
test()
}
// 虽然在代码段中给变量 l 赋值了1，但是编译期间只能识别到初始化int类型切片时，传入的长度和容量是变量l，编译期并不能确定变量l的值，所以发生了逃逸，会把内存分配到堆中。
```

# 如何避免内存逃逸
- 不要盲目使用变量指针作为参数，虽然减少了复制，但变量逃逸的开销更大。
- 预先设定好slice长度，避免频繁超出容量，重新分配。
- 一个经验是，指针指向的数据大部分在堆上分配的，请注意。

# 参考资料
[go 内存逃逸](https://blog.csdn.net/qq_42849214/article/details/124478252)

[Go语言中的内存逃逸现象](https://zhuanlan.zhihu.com/p/441593663)

[面试官：请你详细说说Go的逃逸分析](https://juejin.cn/post/7131947887398748196)
# 概念
go的变量要不在栈上要不在堆上，栈上的变量会在函数销毁的时候就释放了，堆上的就要靠gc算法来了，我们一般说从栈逃逸到堆上或者一开始直接就在堆上的变量内存叫做内存逃逸。
> 函数的内部中不对外开放的局部变量，并只作用于当前函数中的变量，它的内存是分配在栈中。执行函数前会执行进栈操作，函数结束后会出栈，同时释放内存。

# 为什么要尽量避免内存逃逸？
因为如果变量的内存发生逃逸，它的生命周期就是不可知的，其会被分配到堆上，而堆上分配内存不能像栈一样会自动释放，为了解放程序员双手，专注于业务的实现，go实现了gc垃圾回收机制，但gc会影响程序运行性能，所以要尽量减少程序的gc操作。

# 引发内存逃逸的常见情况
- 在方法内把局部变量指针返回，被外部引用，其生命周期大于栈，则溢出。
- 发送指针或带有指针的值到channel，因为编译时候无法知道那个goroutine会在channel接受数据，编译器无法知道什么时候释放。
- 在一个切片上存储指针或带指针的值。比如[]*string，导致切片内容逃逸，其引用值一直在堆上。
- 因为切片的append导致超出容量，切片重新分配地址，切片背后的存储基于运行时的数据进行扩充，就会在堆上分配。
- 在interface类型上调用方法，在Interface调用方法是动态调度的，只有在运行时才知道。

# 如何避免内存逃逸
- 不要盲目使用变量指针作为参数，虽然减少了复制，但变量逃逸的开销更大。
- 预先设定好slice长度，避免频繁超出容量，重新分配。
- 一个经验是，指针指向的数据大部分在堆上分配的，请注意。

# 参考资料
[go 内存逃逸](https://blog.csdn.net/qq_42849214/article/details/124478252)

[Go语言中的内存逃逸现象](https://zhuanlan.zhihu.com/p/441593663)
# 1. 常用的垃圾回收机制
## 1.1 引用计数
每个对象设置一个引用计数器，当有一个地方引用它时，计数器加1；当引用失效时，计数器的值就会减1；任何时刻计数器的值为0的对象就是不可能再被使用的，可以进行回收。

### 缺点
- 频繁更新引用计数降低了性能。
- 循环引用问题。

## 1.2 标记-清除
分为两步：标记与清除。首先从根开始将可能被引用的对象用递归的方式进行标记，然后将没有标记到的对象作为垃圾进行回收。

### 缺点
- 碎片化：回收后分块不是连续的。
- 分配速度：因为分块不是连续的，因此每次分块都要遍历找到足够大的分块，从而造成时间的浪费。
- STW问题。

## 1.3 复制算法
复制算法就是将内存空间按容量分成两块。当这一块内存用完的时候，就将还存活着的对象复制到另外一块上面，然后把已经使用过的这一块一次清理掉。这样使得每次都是对半块内存进行内存回收。内存分配时就不用考虑内存碎片等复杂情况，只要移动堆顶的指针，按顺序分配内存即可，实现简单，运行高效。

### 缺点
- 堆的利用效率低。

## 1.4 分代收集
分代收集的基本思想是，将堆划分为两个或多个称为 代（generation）的空间。新创建的对象存放在称为 新生代（young generation）中（一般来说，新生代的大小会比 老年代小很多），随着垃圾回收的重复执行，生命周期较长的对象会被 提升（promotion）到老年代中。因此，新生代垃圾回收和老年代垃圾回收两种不同的垃圾回收方式应运而生，分别用于对各自空间中的对象执行垃圾回收。

# 2. 三色标记法
Golang使用的GC方法为三色标记法，属于标记-清除方法的一种。

## 2.1 示意图
<img src="https://raw.githubusercontent.com/dark-tone/notes/main/Golang/imgs/1.gif" weight="635" height="401">

## 2.2 算法步骤
1. 初始时，所有对象都在 【白色集合】中；
2. 将GC Roots 直接引用到的对象 挪到 【灰色集合】中；
3. 从灰色集合中获取对象：<br>
    3.1. 将本对象 引用到的 其他对象 全部挪到 【灰色集合】中；<br>
    3.2. 将本对象 挪到 【黑色集合】里面。
4. 重复步骤3，直至【灰色集合】为空时结束。
5. 结束后，仍在【白色集合】的对象即为GC Roots 不可达，可以进行回收。

## 2.3 多标
<img src="https://raw.githubusercontent.com/dark-tone/notes/main/Golang/imgs/2.png" weight="615" height="378">

已被标为灰色的对象，此时若将该对象的引用删除，按道理需要将此对象以及引用此对象的部分对象内存回收。但是已经被标为灰色了，其仍会被当作存活对象继续遍历下去，这部分本应该回收但是没有回收到的内存，被称之为“浮动垃圾”。浮动垃圾并不会影响应用程序的正确性，只是需要等到下一轮垃圾回收中才被清除。

## 2.4 漏标
<img src="https://raw.githubusercontent.com/dark-tone/notes/main/Golang/imgs/3.png" weight="620" height="389"><br>
遍历到E时，将D的引用指向G，此时由于D已经被标为黑色不会再遍历，G会一直停留在白色集合中，最后被当作垃圾进行清除。

### 2.4.1 写屏障
所谓的写屏障，其实就是指在赋值操作前后，加入一些处理。
#### （1）写屏障 + SATB
**【当原来成员变量的引用发生变化之前，记录下原来的引用对象】**

这种做法的思路是：尝试保留开始时的对象图，即原始快照（Snapshot At The Beginning，SATB），当某个时刻 的GC Roots确定后，当时的对象图就已经确定了。

比如 当时 D是引用着G的，那后续的标记也应该是按照这个时刻的对象图走（D引用着G）。如果期间发生变化，则可以记录起来，保证标记依然按照原本的视图来。

值得一提的是，扫描所有GC Roots 这个操作（即初始标记）通常是需要STW的，否则有可能永远都扫不完，因为并发期间可能增加新的GC Roots。

#### （2）写屏障 + 增量更新
**【当有新引用插入进来时，记录下新的引用对象】**

这种做法的思路是：不要求保留原始快照，而是针对新增的引用，将其记录下来等待遍历，即增量更新（Incremental Update）。

### 2.4.2 读屏障
当读取成员变量时，一律记录下来。

## 2.5 STW问题
为了保证准确性、防止无止境的内存增长等问题而不可避免的需要停止赋值器进一步操作对象图以完成垃圾回收。 

### 2.5.1 GC过程
#### 阶段1：Mark Setup 标记准备
会开启屏障，以保证三色标记能在并发情况下正确运行。（期间会STW）

#### 阶段2：Marking 标记

本阶段会与项目代码**一起并发执行**。从各个根节点开始遍历，为对象进行着色。

在标记开始的时候，收集器会默认抢占 25% 的 CPU 性能，剩下的75%会分配给程序执行。但是一旦收集器认为来不及进行标记任务了，就会改变这个 25% 的性能分配。这个时候收集器会抢占程序额外的 CPU，这部分被抢占 goroutine 有个名字叫 Mark Assist。而且因为抢占 CPU的目的主要是 GC 来不及标记新增的内存，那么抢占正在分配内存的 goroutine 效果会更加好，所以分配内存速度越快的 goroutine 就会被抢占越多的资源。

#### 阶段3：Mark Termination 标记结束
这个阶段会关闭掉阶段1开启的屏障，并计算下一次清理的目标和计划。（本阶段会STW）

#### 阶段4：Sweeping 清理
本阶段会**并发执行**，清除前面标记出来需清理的内存。 

# 参考资料
[GC 的三种基本实现方式](https://blog.csdn.net/longzw0/article/details/66970832?spm=1001.2101.3001.6661.1&utm_medium=distribute.pc_relevant_t0.none-task-blog-2%7Edefault%7ECTRLIST%7Edefault-1.essearch_pc_relevant&depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-2%7Edefault%7ECTRLIST%7Edefault-1.essearch_pc_relevant)

[Golang GC 垃圾回收机制详解](https://blog.csdn.net/u010649766/article/details/80582153)

[几种常见GC算法介绍](https://blog.csdn.net/iva_brother/article/details/87870576)

[Golang垃圾回收简明教程1--三色标记法](https://zhuanlan.zhihu.com/p/339772172)

[三色标记法与读写屏障](https://www.jianshu.com/p/12544c0ad5c1)

[Golang GC ：三色标记法](https://zhuanlan.zhihu.com/p/385650396)
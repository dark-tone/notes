# 事务属性
- 原子性（Atomicity），可以理解为一个事务内的所有操作要么都执行，要么都不执行。
- 一致性（Consistency），可以理解为数据是满足完整性约束的，也就是不会存在中间状态的数据，比如你账上有400，我账上有100，你给我打200块，此时你账上的钱应该是200，我账上的钱应该是300，不会存在我账上钱加了，你账上钱没扣的中间状态。
- 隔离性（Isolation），指的是多个事务并发执行的时候不会互相干扰，即一个事务内部的数据对于其他事务来说是隔离的。
- 持久性（Durability），指的是一个事务完成了之后数据就被永远保存下来，之后的其他操作或故障都不会对事务的结果产生影响。

# CAP理论
**一致性(C：Consistency)**：一致性是指数据在多个副本之间能否保持一致的特性。例如一个数据在某个分区节点更新之后，在其他分区节点读出来的数据也是更新之后的数据。

**可用性(A：Availability)**：可用性是指系统提供的服务必须一直处于可用的状态，对于用户的每一个操作请求总是能够在有限的时间内返回结果。这里的重点是"有限时间内"和"返回结果"。

**分区容错性（P:Partition tolerance）**:分布式系统在遇到任何网络分区故障的时候，仍然需要能够保证对外提供满足一致性 **或** 可用性的服务。

一个分布式系统中，CAP理论它只能同时满足（一致性、可用性、分区容错性）中的两点。

# BASE 理论
BASE 理论， 是对CAP中AP的一个扩展，对于我们的业务系统，我们考虑牺牲一致性来换取系统的可用性和分区容错性。BASE是Basically Available(基本可用)，Soft state（软状态）,和 Eventually consistent（最终一致性）三个短语的缩写。

基本可用是指，通过支持局部故障而不是系统全局故障来实现的；
Soft State表示状态可以有一段时间不同步；
最终一致，最终数据是一致的就可以了，而不是实时保持强一致。

# 解决方案
## 2PC
2PC 引入一个**事务协调者**的角色来协调管理各参与者（也可称之为各本地资源）的提交和回滚，二阶段分别指的是**准备**（投票）和**提交**两个阶段。

准备阶段协调者会给各参与者发送准备命令，你可以把准备命令理解成除了提交事务之外啥事都做完了。同步等待所有资源的响应之后就进入第二阶段即提交阶段（注意提交阶段不一定是提交事务，也可能是回滚事务）。假如在第一阶段所有参与者都返回准备成功，那么协调者则向所有参与者发送提交事务命令，然后等待所有事务都提交成功之后，返回事务执行成功。

<img src="https://raw.githubusercontent.com/dark-tone/notes/main/分布式/imgs/1.jpg">

缺陷：
- 同步阻塞：所有的参与者都是事务同步阻塞型的。当参与者占有公共资源时，其他第三方节点访问公共资源不得不处于阻塞状态。
- 单点故障：一旦协调器发生故障，系统不可用。
- 数据不一致：当协调器发送commit之后，有的参与者收到commit消息，事务执行成功，有的没有收到，处于阻塞状态，这段时间会产生数据不一致性。
- 不确定性：当协调器发送commit之后，并且此时只有一个参与者收到了commit，那么当该参与者与协调器同时宕机之后，重新选举的协调器无法确定该条消息是否提交成功。


## 3PC
2PC 中只有协调者有超时机制，3PC 在协调者和参与者中都引入了超时机制，协调者出现故障后，参与者就不会一直阻塞。而且在第一阶段和第二阶段中又插入了一个预提交阶段，**保证了在最后提交阶段之前各参与节点的状态是一致的**。

3PC 包含了三个阶段，分别是**准备阶段**、**预提交阶段**和**提交阶段**，对应的英文就是：CanCommit、PreCommit 和 DoCommit。


## TCC
所谓的 TCC 编程模式，也是两阶段提交的一个变种，不同的是 TCC 为在**业务层**编写代码实现的两阶段提交。TCC 分别指 Try、Confirm、Cancel ，一个业务操作要对应的写这三个方法。

TCC 不存在资源阻塞的问题，因为每个方法都直接进行事务的提交，一旦出现异常通过则 Cancel 来进行回滚补偿，这也就是常说的补偿性事务。


## 本地消息表
<img src="https://raw.githubusercontent.com/dark-tone/notes/main/分布式/imgs/2.awebp">

对于消息发送方：
- 首先需要有一个消息表，记录着消息状态相关信息。
- 业务数据和消息表在同一个数据库，即要保证它俩在同一个本地事务。
- 在本地事务中处理完业务数据和写消息表操作后，通过写消息到MQ消息队列。
- 消息会发到消息消费方，如果发送失败，即进行重试。

消息消费方：
- 处理消息队列中的消息，完成自己的业务逻辑。
- 此时如果本地事务处理成功，则表明已经处理成功了。
- 如果本地事务处理失败，那么就会重试执行。
- 如果是业务上面的失败，给消息生产方发送一个业务补偿消息，通知进行回滚等操作。

本地消息表其实实现的是最终一致性，容忍了数据暂时不一致的情况。

本地消息表方案需要写入消息表中，如果在高并发的场景下会进行大量的磁盘IO，因此该方案不适用于高并发场景。


## 消息事务
<img src="https://raw.githubusercontent.com/dark-tone/notes/main/分布式/imgs/3.jpg">


## 最大努力通知
最大努力通知型( Best-effort delivery)是最简单的一种柔性事务，适用于一些最终一致性时间敏感度低的业务，且被动方处理结果 不影响主动方的处理结果。典型的使用场景：如银行通知、商户通知等。可以采用MQ的ack机制实现。


# 参考资料
[分布式事务六种解决方案](https://zhuanlan.zhihu.com/p/183753774)

[分布式事务解决方案](https://blog.csdn.net/u012811805/article/details/121313006)

[十道经典面试题解析](https://juejin.cn/post/6996803830654435335)

[看了 5 种分布式事务方案，我司最终选择了 Seata，真香！](https://www.cnblogs.com/chengxy-nds/p/14046856.html)

[这六种目前最常见分布式事务解决方案！](https://blog.csdn.net/JavaShark/article/details/125350886)

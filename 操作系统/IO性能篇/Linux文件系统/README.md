# 索引节点和目录项
在 Linux 中一切皆文件。不仅普通的文件和目录，就连块设备、套接字、管道等，也都要通过统一的文件系统来管理。

Linux 文件系统为每个文件都分配两个数据结构，索引节点（index node）和目录项（directory entry）。它们主要用来记录文件的元信息和目录结构。索引节点，简称为 inode，用来记录文件的元数据，比如 inode 编号、文件大小、访问权限、修改日期、数据的位置等。
- 索引节点和文件一一对应，它跟文件内容一样，都会被持久化存储到磁盘中。所以记住，索引节点同样占用磁盘空间。
- 目录项，简称为 dentry，用来记录文件的名字、索引节点指针以及与其他目录项的关联关系。多个关联的目录项，就构成了文件系统的目录结构。不过，不同于索引节点，目录项是由内核维护的一个内存数据结构，所以通常也被叫做目录项缓存。

换句话说，索引节点是每个文件的唯一标志，而目录项维护的正是文件系统的树状结构。目录项和索引节点的关系是多对一，你可以简单理解为，一个文件可以有多个别名。

磁盘读写的最小单位是扇区，然而扇区只有 512B 大小，如果每次都读写这么小的单位，效率一定很低。所以，文件系统又把连续的扇区组成了逻辑块，然后每次都以逻辑块为最小单元，来管理数据。常见的逻辑块大小为 4KB，也就是由连续的 8 个扇区组成。
- 机械磁盘的最小读写单位是扇区，一般大小为 512 字节。
- 固态磁盘的最小读写单位是页，通常大小是 4KB、8KB 等。

示意图：<br>
<img src="https://raw.githubusercontent.com/dark-tone/notes/main/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/imgs/9.webp" style="max-width: 70%;">

目录项本身就是一个内存缓存，而索引节点则是存储在磁盘中的数据。

磁盘在执行文件系统格式化时，会被分成三个存储区域，超级块、索引节点区和数据块区。
- 超级块，存储整个文件系统的状态。
- 索引节点区，用来存储索引节点。
- 数据块区，则用来存储文件数据。

# 硬链接与软链接
硬连接文件的目录项和原文件目录项指向同一个索引节点，索引节点的引用计数会加1，如果原目录项被删除（即原文件被删除），或硬连接被删除，只要索引节点的引用计数不为0，其它目录项就可以访问到文件数据。硬连接不能指向目录。

软连接**不仅会有新的目录项还会创建一个新的索引节点**，索引节点对应的逻辑块中存储的数据是被链接文件的目录和索引节点（重点）。即软连接和被链接文件具有不同的索引节点，如原文件被删除了，因为原文件的索引节点没有被其他引用，所以变为0，那么索引节点和索引节点对应的数据块就会被删除，那么此时软连接访问时发现自己的索引节点中存储的被链接文件的目录在磁盘中不存在了，就会出错，现象是软连接变红。

# 虚拟文件系统
目录项、索引节点、逻辑块以及超级块，构成了 Linux 文件系统的四大基本要素。不过，为了支持各种不同的文件系统，Linux 内核在用户进程和文件系统的中间，又引入了一个抽象层，也就是虚拟文件系统 VFS（Virtual File System）。

VFS 定义了一组所有文件系统都支持的数据结构和标准接口。这样，用户进程和内核中的其他子系统，只需要跟 VFS 提供的统一接口进行交互就可以了，而不需要再关心底层各种文件系统的实现细节。

文件系统架构图：<br>
<img src="https://raw.githubusercontent.com/dark-tone/notes/main/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/imgs/10.webp" style="max-width: 70%;">

文件系统可以分为三类：
- 第一类是基于**磁盘**的文件系统，也就是把数据直接存储在计算机本地挂载的磁盘中。常见的 Ext4、XFS、OverlayFS 等，都是这类文件系统。
- 第二类是基于**内存**的文件系统，也就是我们常说的虚拟文件系统。这类文件系统，不需要任何磁盘分配存储空间，但会占用内存。我们经常用到的 /proc 文件系统，其实就是一种最常见的虚拟文件系统。此外，/sys 文件系统也属于这一类，主要向用户空间导出层次化的内核对象。
- 第三类是**网络**文件系统，也就是用来访问其他计算机数据的文件系统，比如 NFS、SMB、iSCSI 等。

这些文件系统，要先挂载到 VFS 目录树中的某个子目录（称为挂载点），然后才能访问其中的文件。拿第一类，也就是基于磁盘的文件系统为例，在安装系统时，要先挂载一个根目录（/），在根目录下再把其他文件系统（比如其他的磁盘分区、/proc 文件系统、/sys 文件系统、NFS 等）挂载进来。

# 容量
df查看磁盘容量命令
```
$ df -h /dev/sda1 
Filesystem      Size  Used Avail Use% Mounted on 
/dev/sda1        29G  3.1G   26G  11% / 

// -i 参数，可查看索引节点的使用情况
```
有时候，明明你碰到了空间不足的问题，可是用 df 查看磁盘空间后，却发现剩余空间还有很多。很有可能是由于索引节点的容量，（也就是 Inode 个数）是在格式化磁盘时设定好的，一般由格式化工具自动生成。索引节点空间不足，但磁盘空间充足时，很可能就是过多小文件导致的。所以，一般来说，删除这些小文件，或者把它们移动到索引节点充足的其他磁盘中，就可以解决这个问题。

# 常见问题
## too many open file
too many open files是Linux系统中常见的错误，从字面意思上看就是说程序打开的文件数过多，不过这里的files不单是文件的意思，也包括打开的通讯链接(比如socket)，正在监听的端口等等，所以有时候也可以叫做句柄(handle)，这个错误通常也可以叫做句柄数超出系统限制。 
引起的原因就是进程在某个时刻打开了超过系统限制的文件数量以及通讯链接数，通过命令ulimit -a可以查看当前系统设置的最大句柄数是多少

使用命令lsof -p 进程id可以查看单个进程所有打开的文件详情，使用命令lsof -p 进程id | wc -l可以统计进程打开了多少文件，如果文件数过多使用lsof -p 进程id命令无法完全查看的话，可以使用lsof -p 进程id > openfiles.log将执行结果内容输出到日志文件中查看。

可以通过命令行或配置文件增大允许打开的文件数
- 命令行（暂时）：ulimit -n 2048
- 配置文件（永久）：vim /etc/security/limits.conf，在最后加上* - nofile 8192

# 参考资料
[错误异常too many open files解决方法](https://blog.csdn.net/qq_18298439/article/details/83896777)
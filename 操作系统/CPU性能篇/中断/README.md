## 硬中断
直接处理硬件请求，也就是我们常说的硬中断，特点是快速执行；

## 软中断
内核触发，也就是我们常说的软中断，特点是延迟执行。软中断包括网络收发、定时、调度、RCU 锁等各种类型。

在 Linux 中，每个 CPU 都对应一个软中断内核线程，名字是 ksoftirqd/CPU 编号。当软中断事件的频率过高时，内核线程也会因为 CPU 使用率过高而导致软中断处理不及时，进而引发网络收发延迟、调度缓慢等性能问题。

## 实现
硬中断是通过给CPU物理引脚施加电压变化，而软中断是通过给内存中的一个变量的二进制值以通知软中断处理程序。

## 为什么分两种
硬件请求是随时都会发生的，当硬件请求发生时（比如网络接收），需要CPU中断当前处理的程序对其进行处理，此谓硬中断。但是如果硬中断持续太长时间，势必会影响流畅性，因此硬中断仅进行一些简单处理，后续再交给软中断处理。

## 查看
- /proc/softirqs 提供了软中断的运行情况。
- /proc/interrupts 提供了硬中断的运行情况。

两文件记录的是**系统运行以来**的累积中断次数。

## 例子
以sync flood攻击为例的排查思路：
1. 当发现服务器或业务卡顿的时候，首先通过top命令来查看服务器负载，cpu使用率和各个cpu参数，然后排查cpu占用较高的进程；
2. 如果发现cpu使用率并不高，但是si很高，而且ksoftirqd进程cpu占用率高，则说明服务器一直在发生软中断；
3. 通过cat /proc/softirqs来分析是哪方面的软中断次数最多，可以通过watch命令来查看变化最快的值；(watch -d "cat /proc/softirqs")
4. 一般情况下网络发生中断的情况会比较多，如果发现是网络收发包导致的软中断，则通过sar命令来查看此时的收发包速率和收发包数据量来验证是否真的是网络收发包过多导致，也可以计算每个包的大小，以此来计算服务器是否收到了flood攻击；
5. 通过tcpdump来抓包分析数据包来源ip和数据包类型，通过抓包数据中的Flags来分析数据包类型；
6. 通过防火墙封堵异常ip；
